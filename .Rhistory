set.seed(2018)
p <- 50; n <- 1000;sparsity <- 2/p
## generate a random lower triangular adjacnecy matrix
A <- matrix(rbinom(p*p, 1, sparsity)*sign(runif(p*p, -1, 1))*runif(p*p, 0.7, 1), p, p)
A[upper.tri(A, diag=TRUE)] <- 0
## num of edges in A
sum(A != 0) # 43
## data matrix
X <- matrix(rnorm(n*p), n, p) %*% t(solve(diag(p) - A))
#Loglikelihood
loglikelihood=function(A,sigma_square,X){
n=ncol(X)
p=nrow(X)
tot=0
for (j in 1:n){
somma2=0
for (i in 1:p){
somma1=0
for (k in 1:n){
if (k!=j){
somma1=somma1+A[j,k]*X[j,k]
}
}
partial=X[i,j]-somma1
}
somma2=somma2+partial^2
}
tot=tot+(1/(2*sigma_square)*somma2+n*log(sigma_square)/2)
return(-tot)
}
#generate D matrix
#number of hyphothesized edges
q=43
D <- matrix(0, p, p)
index1=sample(1:p,q,replace=TRUE)
index2=sample(1:p,q,replace=TRUE)
for (i in 1:q){
D[index1[i],index2[i]]=1
}
#MLEdag method to recover A.H0 and A.H1
out=MLEdag(X=X,D=D,tau=0.3, mu=1, rho=1.2)
A_costrained=out$A.H0
A_uncostrained=out$A.H1
#loglikelihood as a function of just sigma squared
l_sigma=function(A,sigma_square,X){
#perform the loglikelihood in function of sigma squared
function1=function(sigma_square){
loglikelihood(A=A,sigma_square=sigma_square,X=X)
}
return(function1)
}
#sigma_square,loglikelihood costrained
out_costrained=optim(par=c(1),fn=l_sigma(A_costrained,sigma_square,X),method=c("Brent"),lower = 0, upper = 10000,control = list(fnscale = -1))
best_sigma_squared_costrained=out_costrained$par
maximum_value_l_costrained=out_costrained$value
likelihood_costrained=exp(maximum_value_l_costrained)
#sigma_squared, loglikelihood uncostrained
out_uncostrained=optim(par=c(1),fn=l_sigma(A_uncostrained,sigma_square,X),method=c("Brent"),lower = 0, upper = 10000,control = list(fnscale = -1))
best_sigma_squared_uncostrained=out_uncostrained$par
maximum_value_l_uncostrained=out_uncostrained$value
likelihood_uncostrained=exp(maximum_value_l_uncostrained)
#Built the statistic U_n
U=likelihood_uncostrained/likelihood_costrained
#Comment
# U=1, so for alpha=0.05, we can not reject the null hypothesis
# Part 3 ------------------------------------------------------------------
set.seed(2018)
p <- 25; n <- 200;sparsity <- 2/p
## generate a random lower triangular adjacnecy matrix
A <- matrix(rbinom(p*p, 1, sparsity)*sign(runif(p*p, -1, 1))*runif(p*p, 0.7, 1), p, p)
A[upper.tri(A, diag=TRUE)] <- 0
## num of edges in A
sum(A != 0) # 43
## data matrix
X <- matrix(rnorm(n*p), n, p) %*% t(solve(diag(p) - A))
#Loglikelihood
loglikelihood=function(A,sigma_square,X){
n=ncol(X)
p=nrow(X)
tot=0
for (j in 1:n){
somma2=0
for (i in 1:p){
somma1=0
for (k in 1:n){
if (k!=j){
somma1=somma1+A[j,k]*X[j,k]
}
}
partial=X[i,j]-somma1
}
somma2=somma2+partial^2
}
tot=tot+(1/(2*sigma_square)*somma2+n*log(sigma_square)/2)
return(-tot)
}
#generate D matrix
#number of hyphothesized edges
q=43
D <- matrix(0, p, p)
index1=sample(1:p,q,replace=TRUE)
index2=sample(1:p,q,replace=TRUE)
for (i in 1:q){
D[index1[i],index2[i]]=1
}
#MLEdag method to recover A.H0 and A.H1
out=MLEdag(X=X,D=D,tau=0.3, mu=1, rho=1.2)
A_costrained=out$A.H0
A_uncostrained=out$A.H1
#loglikelihood as a function of just sigma squared
l_sigma=function(A,sigma_square,X){
#perform the loglikelihood in function of sigma squared
function1=function(sigma_square){
loglikelihood(A=A,sigma_square=sigma_square,X=X)
}
return(function1)
}
#sigma_square,loglikelihood costrained
out_costrained=optim(par=c(1),fn=l_sigma(A_costrained,sigma_square,X),method=c("Brent"),lower = 0, upper = 10000,control = list(fnscale = -1))
best_sigma_squared_costrained=out_costrained$par
maximum_value_l_costrained=out_costrained$value
likelihood_costrained=exp(maximum_value_l_costrained)
#sigma_squared, loglikelihood uncostrained
out_uncostrained=optim(par=c(1),fn=l_sigma(A_uncostrained,sigma_square,X),method=c("Brent"),lower = 0, upper = 10000,control = list(fnscale = -1))
best_sigma_squared_uncostrained=out_uncostrained$par
maximum_value_l_uncostrained=out_uncostrained$value
likelihood_uncostrained=exp(maximum_value_l_uncostrained)
#Built the statistic U_n
U=likelihood_uncostrained/likelihood_costrained
#Comment
# U=35.95, so for alpha=0.05, we reject the null hypothesis
set.seed(2018)
p <- 25; n <- 2000;sparsity <- 2/p
## generate a random lower triangular adjacnecy matrix
A <- matrix(rbinom(p*p, 1, sparsity)*sign(runif(p*p, -1, 1))*runif(p*p, 0.7, 1), p, p)
A[upper.tri(A, diag=TRUE)] <- 0
sum(A != 0) # 43
X <- matrix(rnorm(n*p), n, p) %*% t(solve(diag(p) - A))
#Loglikelihood
loglikelihood=function(A,sigma_square,X){
n=ncol(X)
p=nrow(X)
tot=0
for (j in 1:n){
somma2=0
for (i in 1:p){
somma1=0
for (k in 1:n){
if (k!=j){
somma1=somma1+A[j,k]*X[j,k]
}
}
partial=X[i,j]-somma1
}
somma2=somma2+partial^2
}
tot=tot+(1/(2*sigma_square)*somma2+n*log(sigma_square)/2)
return(-tot)
}
#generate D matrix
#number of hyphothesized edges
q=20
D <- matrix(0, p, p)
index1=sample(1:p,q,replace=TRUE)
index2=sample(1:p,q,replace=TRUE)
for (i in 1:q){
D[index1[i],index2[i]]=1
}
#MLEdag method to recover A.H0 and A.H1
out=MLEdag(X=X,D=D,tau=0.3, mu=1, rho=1.2)
A_costrained=out$A.H0
A_uncostrained=out$A.H1
#loglikelihood as a function of just sigma squared
l_sigma=function(A,sigma_square,X){
#perform the loglikelihood in function of sigma squared
function1=function(sigma_square){
loglikelihood(A=A,sigma_square=sigma_square,X=X)
}
return(function1)
}
#sigma_square,loglikelihood costrained
out_costrained=optim(par=c(1),fn=l_sigma(A_costrained,sigma_square,X),method=c("Brent"),lower = 0, upper = 10000,control = list(fnscale = -1))
best_sigma_squared_costrained=out_costrained$par
maximum_value_l_costrained=out_costrained$value
likelihood_costrained=exp(maximum_value_l_costrained)
#sigma_squared, loglikelihood uncostrained
out_uncostrained=optim(par=c(1),fn=l_sigma(A_uncostrained,sigma_square,X),method=c("Brent"),lower = 0, upper = 10000,control = list(fnscale = -1))
best_sigma_squared_uncostrained=out_uncostrained$par
maximum_value_l_uncostrained=out_uncostrained$value
likelihood_uncostrained=exp(maximum_value_l_uncostrained)
#Built the statistic U_n
U=likelihood_uncostrained/likelihood_costrained
### Parameters
set.seed(2018)
p <- 25
n <- 200
M <- 1000
### H0: F = { (p,2) }, and A[F] = 0
D <- matrix(0, p, p)
D[p,2] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> **COMPATIBLE** with H0
A      <- matrix(0, p, p)
A[, 1] <- sign( runif( p, min = -1, max = 1 ) )
A[1,1] <- 0
### Visualize
# install.packages("igraph")
suppressMessages( require(igraph, quietly = T ) )
# url: https://kateto.net/netscix2016.html
g  <- graph.adjacency(A, weighted = TRUE)
df <- get.data.frame(g)
head(df)
V(g)$color    <- "gold"
V(g)$color[1] <- "green" # Hub
V(g)$color[p] <- "red"   # Node in H0
V(g)$color[2] <- "red"   # Node in H0
### Viz :: No p -> 2 edge
plot( g,
edge.arrow.size = .15,
vertex.frame.color = "gray", vertex.label.color = "black",
vertex.label.cex = 0.8, vertex.label.dist = 2, edge.curved = 0.2,
layout = layout_with_gem )
# Simulation --------------------------------------------------------------
p_bar <- FALSE # progress-bar yes/no?
if (p_bar){
# install.packages("svMisc")
suppressMessages( require(svMisc, quietly = T ) ); ?progress
}
str_time <- Sys.time()
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
# Take a look: (M = 1000, n = 200)
# Are we simulating under H0 as expected here?
# If so, the pval should be Unif(0,1)
hist(pval, prob = T, border = "white")  # close enough!
abline(h = 1, lty = 2, col = "red")
mean(pval < 0.05)   # proportion under 0.05
mean(pval < 0.01)   # proportion under 0.01
### Parameters
set.seed(2018)
p <- 25
n <- 200
M <- 1000
### H0: F = { (p,2) }, and A[F] = 0
D <- matrix(0, p, p)
D[p,2] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> **COMPATIBLE** with H0
A      <- matrix(0, p, p)
A[, 1] <- sign( runif( p, min = -1, max = 1 ) )
A[1,1] <- 0
A
install.packages("igraph")
install.packages("igraph")
suppressMessages( require(igraph, quietly = T ) )
g  <- graph.adjacency(A, weighted = TRUE)
df <- get.data.frame(g)
head(df)
V(g)$color    <- "gold"
V(g)$color[1] <- "green" # Hub
V(g)$color[p] <- "red"   # Node in H0
V(g)$color[2] <- "red"   # Node in H0
### Viz :: No p -> 2 edge
plot( g,
edge.arrow.size = .15,
vertex.frame.color = "gray", vertex.label.color = "black",
vertex.label.cex = 0.8, vertex.label.dist = 2, edge.curved = 0.2,
layout = layout_with_gem )
p_bar <- FALSE # progress-bar yes/no?
if (p_bar){
# install.packages("svMisc")
suppressMessages( require(svMisc, quietly = T ) ); ?progress
}
str_time <- Sys.time()
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
hist(pval, prob = T, border = "white")  # close enough!
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (p_bar) progress(i, M)
}
library(clrdag)
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (p_bar) progress(i, M)
}
for(i in 429:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (p_bar) progress(i, M)
}
hist(pval, prob = T, border = "white")  # close enough!
abline(h = 1, lty = 2, col = "red")
mean(pval < 0.05)   # proportion under 0.05
mean(pval < 0.01)   # proportion under 0.01
cat('alpha is equal to ',1)
cat('alpha is equal to ', 2/M)
### Parameters
set.seed(2018)
p <- 25
n <- 200
M <- 1000
### H0: F = { (p,2),(2,2) }, and A[F] = 0
D <- matrix(0, p, p)
D[p,2] = 1
D[2,2] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> **COMPATIBLE** with H0
A      <- matrix(0, p, p)
A[, 1] <- sign( runif( p, min = -1, max = 1 ) )
A[1,1] <- 0
p_bar <- FALSE # progress-bar yes/no?
if (p_bar){
# install.packages("svMisc")
suppressMessages( require(svMisc, quietly = T ) ); ?progress
}
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if pval[i]<0.05 cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if out$pval<0.05 {cont=cont+1}
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (p_bar) progress(i, M)
}
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (pval[i]<0.05) cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
cat('alpha is equal to ', cont/M)
### H0: F = { (p,2),(2,2) }, and A[F] = 0
D <- matrix(0, p, p)
D[p,2] = 1
D[2,2] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> ** NOT COMPATIBLE** with H0
A      <- matrix(0, p, p)
A[, 1] <- sign( runif( p, min = -1, max = 1 ) )
A[2,2] <- 0
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (pval[i]<0.05) cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
cat('alpha is equal to ', cont/M)
cat('Beta is equal to ', cont/M)
hist(pval, prob = T, border = "white")  # close enough!
abline(h = 1, lty = 2, col = "red")
mean(pval < 0.05)   # proportion under 0.05
mean(pval < 0.01)   # proportion under 0.01
A      <- matrix(0, p, p)
A[, 1] = sign( runif( p, min = -1, max = 1 ) )
A[2,2] = 0
A[p,2] =0
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (pval[i]>0.05) cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
cat('Beta is equal to ', cont/M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (pval[i]>0.05) cont=cont+1
if (p_bar) progress(i, M)
}
A      <- matrix(0, p, p)
A[, 1] = sign( runif( p, min = -1, max = 1 ) )
A[2,2] = 0
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (pval[i]>0.05) cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
cat('Beta is equal to ', cont/M)
cat('1-Beta is equal to ', cont/M)
D <- matrix(0, p, p)
D[p,2] = 1
D[2,2] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> ** NOT COMPATIBLE** with H0
A      <- matrix(0, p, p)
#A[, 1] = sign( runif( p, min = -1, max = 1 ) )
A[2,2] = 0
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
if (pval[i]>0.05) cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
cat('1-Beta is equal to ', cont/M)
cat('1-Beta is equal to ', 1-cont/M)
D[:,2] = 1
D[,2] = 1
D
### H0: F = {(,2) }, and A[F] = 0
D <- matrix(0, p, p)
D[,2] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> ** NOT COMPATIBLE** with H0
A      <- matrix(0, p, p)
A[, 2] = sign( runif( p, min = -1, max = 1 ) )
str_time <- Sys.time()
cont=0
pval <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
out <- MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
pval[i] <- out$pval
# we fail to reject if pval>0.05
if (pval[i]>0.05) cont=cont+1
if (p_bar) progress(i, M)
}
stp_time <- Sys.time()
stp_time - str_time
cat('1-Beta is equal to ', 1-cont/M)
# Take a look: (M = 1000, n = 200)
# Are we simulating under H0 as expected here?
# If so, the pval should be Unif(0,1)
hist(pval, prob = T, border = "white")  # close enough!
