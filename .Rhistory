A.link.hidden[6, 3] = 1
A.link.hidden[10, 9] =1
'''
# SIMULATION
contU=0
contW=0
alpha=0.05
M=10
U_n <- rep(NA, M)
W_n <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
temp=log.LRT(X,D, links=T)
U_n[i]=temp$U_n
W_n[i]=temp$W_n
if (U_n[i]>log(1/alpha)) contU=contU+1
if (W_n[i]>log(1/alpha)) contW=contW+1
}
cat('1-beta is equal to for U: ', contU/M,'   ,1-beta is equal to for W:',contW/M)
# PART 4 ------------------------------------------------------------------
### H0: F = { (p,1) }, and A[F] = 0
D <- matrix(0, p, p)
D[p,1] = 1
### Adjacency Matrix >> Hub
# All connected to 1, NO EDGE between p-2 >> **NOT COMPATIBLE** with H0
A      <- matrix(0, p, p)
A[2:p, 1] <- sign( runif( p-1, min = -1, max = 1 ) )
A[3,4]=1
A[4,5]=1
'''
D.link = matrix(0, p, p)
D.link[2, 1] = 1
D.link[6, 3] = 1
D.link[10, 9] = 1
# Building A accordingly to h0
A.link.hidden = matrix(rbinom(p*p,1,sparsity)*sign(runif(p*p,min=-1,max=1)),p,p)
A.link.hidden[upper.tri(A.link.hidden, diag = T)] = 0
A.link.hidden[2, 1] = 1#as.integer(!h0)
A.link.hidden[6, 3] = 1
A.link.hidden[10, 9] =1
'''
# SIMULATION
contU=0
contW=0
alpha=0.05
M=10
U_n <- rep(NA, M)
W_n <- rep(NA, M)
for(i in 1:M) {
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
temp=log.LRT(X,D, links=T)
U_n[i]=temp$U_n
W_n[i]=temp$W_n
if (U_n[i]>log(1/alpha)) contU=contU+1
if (W_n[i]>log(1/alpha)) contW=contW+1
}
cat('1-beta is equal to for U: ', contU/M,'   ,1-beta is equal to for W:',contW/M)
U_n
getwd()
concatenated_data=read.csv("data/cell_signaling/concatenated.csv",header=True,sep=",")
concatenated_data=read.csv("data/cell_signaling/concatenated.csv",header=T,sep=",")
data=read.csv("data/cell_signaling/concatenated.csv",header=T,sep=",")
data.head(5)
head(data,n=5)
library(clrdag)
compute.middle = function(X,A,j, p){
# Finding the indexes K = {k s.t. k is in [1,p]\j}
K = which((1:p)!=j)
# in k we have the indexes of the row without j
inners = apply(X[, K] * A[j, K], 1, sum) # n length vector containing the inner sums for each i-th sample
middle = sum((X[, j] - inners)^2)  # as a matter of fact in the middle we are working on the j-th column
return(middle)
}
sigma.estimator = function(X, A){
n = dim(X)[1]
p = dim(X)[2]
return(sum(sapply(1:p, function(j)compute.middle(X,A,j, p)))/(n*p))
}
log_likelihood = function(X, A, sigma.square){
n = dim(X)[1]
p = dim(X)[2]
return(-sum(sapply(1:p, function(j) (compute.middle(X,A,j,p)/(2*sigma.square)+(n/2*log(sigma.square))))))
}
inner_LRT_function.paths = function(X, X.tr, X.te, D){
# Computing all the A.h0 over the sparsity parameters 'k'
A.mles = lapply(1:sum(D), function(mu)MLEdag(X, D=D, tau=0.35, mu=mu, rho=1.2, trace_obj = F))
A.h0s  = lapply(A.mles, function(a)a$A.H0)
A.h1s  = lapply(A.mles, function(a)a$A.H1)
# For each A.h0 compute the associated sigma
sigmas.0 = t(sapply(A.h0s, function(a)sigma.estimator(X.tr, a)))
sigmas.1 = t(sapply(A.h1s, function(a)sigma.estimator(X.te, a)))
# Computing the likelihoods of each pair (A.h0, sigma.h0)
likelihoods.0 = t(sapply(1:length(sigmas.0), function(idx)log_likelihood(X.tr, A.h0s[[idx]], sigmas.0[idx])))
likelihoods.1 = t(sapply(1:length(sigmas.1), function(idx)log_likelihood(X.tr, A.h1s[[idx]], sigmas.1[idx])))
# Finding the idx that give us the maximum likelihood
mle_idx.0 = which(likelihoods.0==max(likelihoods.0))[1] # maximum likelihood over h0
mle_idx.1 = which(likelihoods.1==max(likelihoods.1))[1] # maximum likelihood over h0
return (likelihoods.1[mle_idx.1]-likelihoods.0[mle_idx.0])
#return(list(U.n=exp(log_likelihood(X.tr, A, sigma.unconstrained)-likelihoods[mle_idx]), A.h0=A.h0s[[mle_idx]]))
}
inner_LRT_function.links = function(X, X.tr, X.te, D){
tmp = MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
A.h0 = tmp$A.H0
A = tmp$A.H1
sigma.h0 = sigma.estimator(X.tr, A.h0)
sigma.unconstrained = sigma.estimator(X.te, A)
return(log_likelihood(X.tr, A, sigma.unconstrained)-log_likelihood(X.tr, A.h0, sigma.h0))
}
log.LRT = function(X,D, links=T){
n=dim(X)[1]
X.tr = X[1:(n%/%2),]
X.te = X[(n%/%2+1):n,]
if(links){
U_n = inner_LRT_function.links(X, X.tr, X.te, D)
U_n.swap = inner_LRT_function.links(X, X.te, X.tr, D)
}
else{
U_n = inner_LRT_function.paths(X, X.tr, X.te, D)
U_n.swap = inner_LRT_function.paths(X, X.te, X.tr, D)
}
return(list(links = links, U_n = U_n, W_n = (log((exp(U_n)+exp(U_n.swap))/2))))
}
p=11
#FIRST CONNECTION: PIP2->PKC (columns 4  and column 9)
### H0: F = { (p,1) }, and A[F] = 0
D <- matrix(0, p, p)
D[4,9] = 1
alpha=0.05
temp=log.LRT(data,D, links=T)
library(clrdag)
A      <- matrix(0, p, p)
A[2:p, 1] <- sign( runif( p-1, min = -1, max = 1 ) )
A[3,4]=1
A[4,5]=1
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
n <- 200
M <- 1000
X   <- matrix( rnorm(n*p), n, p) %*% t(solve(diag(p) - A) )
temp=log.LRT(X,D, links=T)
temp=log.LRT(X,D, links=T)
D <- matrix(0, p, p)
D[4,9] = 1
alpha=0.05
temp=log.LRT(data,D, links=T)
X=data.matrix(data, rownames.force = NA)
temp=log.LRT(X,D, links=T)
U_n[i]=temp$U_n
temp
U_n=temp$U_n
W_n=temp$W_n
1/alpha
log(1/alpha)
(U_n>log(1/alpha))
cat (U_n>log(1/alpha))
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis")
if(U_n<log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
D <- matrix(0, p, p)
D[3,9] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
#THIRD CONNECTION: PIP3-> AKT (column 5 and 7)
### H0: F = { (4,7) }, and A[F] = 0
D <- matrix(0, p, p)
D[4,7] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
D <- matrix(0, p, p)
D[9,11] = 1
D[9,10] = 1
D[9,1] = 1
D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
log(20)
#PATHWAY LINKAGE
#check all the connections from PKC
#PKC->(JNK,P38,RAF,MEK) which means columns (9->11,10,1,2)
D <- matrix(0, p, p)
D[9,11] = 1
D[9,10] = 1
D[9,1] = 1
#D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
U_n=temp$U_n
D <- matrix(0, p, p)
D[9,11] = 1
D[9,10] = 1
#D[9,1] = 1
#D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
#PATHWAY LINKAGE
#check all the connections from PKC
#PKC->(JNK,P38,RAF,MEK) which means columns (9->11,10,1,2)
D <- matrix(0, p, p)
#D[9,11] = 1
D[9,10] = 1
#D[9,1] = 1
#D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
#PATHWAY LINKAGE
#check all the connections from PKC
#PKC->(JNK,P38,RAF,MEK) which means columns (9->11,10,1,2)
D <- matrix(0, p, p)
#D[9,11] = 1
#D[9,10] = 1
#D[9,1] = 1
#D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
#PATHWAY LINKAGE
#check all the connections from PKC
#PKC->(JNK,P38,RAF,MEK) which means columns (9->11,10,1,2)
D <- matrix(0, p, p)
#D[9,11] = 1
#D[9,10] = 1
#D[9,1] = 1
D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "W_n": W_n)
#PATHWAY LINKAGE
#check all the connections from PKC
#PKC->(JNK,P38,RAF,MEK) which means columns (9->11,10,1,2)
D <- matrix(0, p, p)
D[9,11] = 1
D[9,10] = 1
D[9,1] = 1
D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "W_n": W_n)
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
U_n
W_n=temp$W_n
cat("U_n:", U_n, "W_n": W_n)
cat("U_n:", U_n, "W_n:", W_n)
cat("U_n:", U_n, "   W_n:", W_n)
D <- matrix(0, p, p)
D[9,11] = 1
#D[9,10] = 1
D[9,1] = 1
D[9,2] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
#LEt's try another test
# PKc->Jnk and PKA->P38
#columns (9->11 and 8->10)
D <- matrix(0, p, p)
D[9,11] = 1
D[8,10] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
D <- matrix(0, p, p)
D[9,8] = 1
D[6,7] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
#LAST: reported direct connections
# PKC-> PKA and ERK-> AKT columns (9->8 and 6->7)
D <- matrix(0, p, p)
D[9,8] = 1
#D[6,7] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
#LAST: reported direct connections
# PKC-> PKA and ERK-> AKT columns (9->8 and 6->7)
D <- matrix(0, p, p)
#D[9,8] = 1
D[6,7] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
D <- matrix(0, p, p)
D[4,9] = 1
D[3,9] = 1
D[5,7] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
# 4) LAST missed connections:
#PIP2->PKC, Plc-gamma->PKC and PIP3_>Akt columns (4->9,3->9,5->7)
D <- matrix(0, p, p)
#D[4,9] = 1
D[3,9] = 1
D[5,7] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
# 4) LAST missed connections:
#PIP2->PKC, Plc-gamma->PKC and PIP3_>Akt columns (4->9,3->9,5->7)
D <- matrix(0, p, p)
#D[4,9] = 1
#D[3,9] = 1
D[5,7] = 1
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
data=read.csv("data/cell_signaling/pma.csv",header=T,sep=",")
head(data,n=5)
X=data.matrix(data, rownames.force = NA)
qqplot(X[,1])
qqnorm(X[,1])
hist(X[,1])
hist(X[,1],breaks=100)
hist(X[,12],breaks=100)
hist(X[,2],breaks=100)
hist(X[,3],breaks=100)
hist(X[,4],breaks=100)
hist(X[,5],breaks=100)
hist(X[,6],breaks=100)
hist(X[,7],breaks=100)
hist(X[,8],breaks=100)
hist(X[,9],breaks=100)
hist(X[,10],breaks=100)
hist(X[,11],breaks=100)
hist(X[,11],breaks=100)
hist(X[,10],breaks=100)
hist(X[,9],breaks=100)
X.new=scale(X[,9])
hist(X.new,breaks=100)
X.new=scale(X[,9],center=TRUE)
hist(X.new,breaks=100)
a=boxcox(X.new)
install.packages("car")
a=boxcox(X.new)
install.packages("MASS")
a=boxcox(X.new)
boxcox
?boxcox
data=read.csv("data/cell_signaling/pma.csv",header=T,sep=",")
head(data,n=5)
X=data.matrix(data, rownames.force = NA)
hist(X[,4],breaks=100)
a=boxcox(X.new)
boxcox(X.new)
boxcox(X)
boxcox(X)
boxcox(X)
data=read.csv("data/cell_signaling/pma.csv",header=T,sep=",")
head(data,n=5)
X=data.matrix(data, rownames.force = NA)
hist(X[,4],breaks=100)
hist(X[,9],breaks=100)
boxcox(X[,9])
hist(scale(X[,9]),breaks=100)
library(clrdag)
compute.middle = function(X,A,j, p){
# Finding the indexes K = {k s.t. k is in [1,p]\j}
K = which((1:p)!=j)
# in k we have the indexes of the row without j
inners = apply(X[, K] * A[j, K], 1, sum) # n length vector containing the inner sums for each i-th sample
middle = sum((X[, j] - inners)^2)  # as a matter of fact in the middle we are working on the j-th column
return(middle)
}
sigma.estimator = function(X, A){
n = dim(X)[1]
p = dim(X)[2]
return(sum(sapply(1:p, function(j)compute.middle(X,A,j, p)))/(n*p))
}
log_likelihood = function(X, A, sigma.square){
n = dim(X)[1]
p = dim(X)[2]
return(-sum(sapply(1:p, function(j) (compute.middle(X,A,j,p)/(2*sigma.square)+(n/2*log(sigma.square))))))
}
inner_LRT_function.paths = function(X, X.tr, X.te, D){
# Computing all the A.h0 over the sparsity parameters 'k'
A.mles = lapply(1:sum(D), function(mu)MLEdag(X, D=D, tau=0.35, mu=mu, rho=1.2, trace_obj = F))
A.h0s  = lapply(A.mles, function(a)a$A.H0)
A.h1s  = lapply(A.mles, function(a)a$A.H1)
# For each A.h0 compute the associated sigma
sigmas.0 = t(sapply(A.h0s, function(a)sigma.estimator(X.tr, a)))
sigmas.1 = t(sapply(A.h1s, function(a)sigma.estimator(X.te, a)))
# Computing the likelihoods of each pair (A.h0, sigma.h0)
likelihoods.0 = t(sapply(1:length(sigmas.0), function(idx)log_likelihood(X.tr, A.h0s[[idx]], sigmas.0[idx])))
likelihoods.1 = t(sapply(1:length(sigmas.1), function(idx)log_likelihood(X.tr, A.h1s[[idx]], sigmas.1[idx])))
# Finding the idx that give us the maximum likelihood
mle_idx.0 = which(likelihoods.0==max(likelihoods.0))[1] # maximum likelihood over h0
mle_idx.1 = which(likelihoods.1==max(likelihoods.1))[1] # maximum likelihood over h0
return (likelihoods.1[mle_idx.1]-likelihoods.0[mle_idx.0])
#return(list(U.n=exp(log_likelihood(X.tr, A, sigma.unconstrained)-likelihoods[mle_idx]), A.h0=A.h0s[[mle_idx]]))
}
inner_LRT_function.links = function(X, X.tr, X.te, D){
tmp = MLEdag(X = X, D = D, tau = 0.35, mu = 1,
rho = 1.2, trace_obj = FALSE)
A.h0 = tmp$A.H0
A = tmp$A.H1
sigma.h0 = sigma.estimator(X.tr, A.h0)
sigma.unconstrained = sigma.estimator(X.te, A)
return(log_likelihood(X.tr, A, sigma.unconstrained)-log_likelihood(X.tr, A.h0, sigma.h0))
}
log.LRT = function(X,D, links=T){
n=dim(X)[1]
X.tr = X[1:(n%/%2),]
X.te = X[(n%/%2+1):n,]
if(links){
U_n = inner_LRT_function.links(X, X.tr, X.te, D)
U_n.swap = inner_LRT_function.links(X, X.te, X.tr, D)
}
else{
U_n = inner_LRT_function.paths(X, X.tr, X.te, D)
U_n.swap = inner_LRT_function.paths(X, X.te, X.tr, D)
}
return(list(links = links, U_n = U_n, W_n = (log((exp(U_n)+exp(U_n.swap))/2))))
}
D <- matrix(0, p, p)
D[4,9] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
## OKKKK
data=read.csv("data/cell_signaling/concatenated.csv",header=T,sep=",")
head(data,n=5)
X=data.matrix(data, rownames.force = NA)
#data will be our X matrix
p=11
D <- matrix(0, p, p)
D[4,9] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
## OKKKK
#FIRST CONNECTION: PIP2->PKC (columns 4  and column 9)
### H0: F = { (4,9) }, and A[F] = 0
D <- matrix(0, p, p)
D[9,4] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
## OKKKK
#Let's continue
#SECOND CONNECTION: Plc-gamma -> PKC (column 3 and 9)
### H0: F = { (3,9) }, and A[F] = 0
D <- matrix(0, p, p)
D[3,9] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
## OKKKK
#Let's continue
#THIRD CONNECTION: PIP3-> AKT (column 5 and 7)
### H0: F = { (4,7) }, and A[F] = 0
D <- matrix(0, p, p)
D[4,7] = 1
alpha=0.05
temp=log.LRT(X,D, links=T)
U_n=temp$U_n
W_n=temp$W_n
if(U_n>log(1/alpha)) cat(" We can reject the null hypothesis") else cat(" We can not reject the null hypothesis")
## OKKKK
D <- matrix(0, p, p)
D[9,1] = 1
D[9,2] = 1
D[9,6] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
D <- matrix(0, p, p)
D[9,1] = 1
D[1,2] = 1
D[2,6] = 1
alpha=0.05
temp=log.LRT(X,D, links=F)
U_n=temp$U_n
W_n=temp$W_n
cat("U_n:", U_n, "   W_n:", W_n)
